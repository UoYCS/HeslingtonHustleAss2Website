<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PlayScreen.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tests</a> &gt; <a href="index.source.html" class="el_package">com.waddle_ware.heslington_hustle.Screens</a> &gt; <span class="el_source">PlayScreen.java</span></div><h1>PlayScreen.java</h1><pre class="source lang-java linenums">/*
 * CHANGELOG:
 * SEVERAL CHANGES REQUIRED:
 *      MAP
 *          - Updated and Expanding game map
 *          - Required changes to camera and location logic
 *      ACTIVITIES
 *          - Added more activities
 *          - Added floating activity icons
 *      Testing
 *          - Updated code and added new methods to assist in unit testing
 *
 */


package com.waddle_ware.heslington_hustle.Screens;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Screen;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.maps.tiled.TiledMap;
import com.badlogic.gdx.maps.tiled.TmxMapLoader;
import com.badlogic.gdx.maps.tiled.renderers.OrthogonalTiledMapRenderer;
import com.badlogic.gdx.utils.viewport.FitViewport;
import com.badlogic.gdx.utils.viewport.Viewport;
import com.waddle_ware.heslington_hustle.ActivityLocation;
import com.waddle_ware.heslington_hustle.Avatar;
import com.waddle_ware.heslington_hustle.HUD;
import com.waddle_ware.heslington_hustle.HeslingtonHustle;
import com.waddle_ware.heslington_hustle.InteractionPopup;
import com.waddle_ware.heslington_hustle.core.ActivityType;
import com.waddle_ware.heslington_hustle.core.Core;
import com.waddle_ware.heslington_hustle.core.ExitConditions;
import com.waddle_ware.heslington_hustle.core.ResourceExitConditions;

import java.util.Arrays;

/**
 * CHANGELOG: UPDATED CLASS
 * The PlayScreen class represents the games screen where the gameplay is.
 * It implements the Screen interface and manages rendering and input handling.
 */
public class PlayScreen implements Screen {
    private OrthographicCamera camera;
    private Viewport viewport;
    private TiledMap tile_map;
    private OrthogonalTiledMapRenderer map_renderer;
<span class="fc" id="L54">    private boolean is_fullscreen = false;  // Track fullscreen state</span>

    // CHANGELOG: Added attributes to store the users current map section location
    //            -1: Town, 0: WestCampus, 1:EastCampus(StartingZone)
<span class="fc" id="L58">    private int current_map_section = 1;</span>
<span class="fc" id="L59">    private final int map_section_offset = 48*16;</span>

    // CHANGELOG: Added attribute to store # of frames since last activity interaction
<span class="fc" id="L62">    private int frames_since_int = 0;</span>


    public Avatar player;
    private float world_width;
    private float world_height;
    private HUD hud;
    private final HeslingtonHustle game;

    public static final String ICON_ANIMATION_ASSET = &quot;iconAnimations.png&quot;;
    public static final String TILEMAP_ASSET = &quot;MapToCode/map.tmx&quot;;

    public Core core;


    // CHANGELOG: ADDED ACTIVITIES TO ARRAY INSTEAD OF USING VARIABLES TO ALLOW FOR EXTRA ACTIVITIES

    // Define activity locations array
<span class="fc" id="L80">    public final ActivityLocation[] activityLocations = {</span>

            // SLEEPING at Goodricke
            new ActivityLocation(1786, 264, 20, &quot;sleep&quot;, ActivityType.Sleep),

            // STUDYING at Library
            new ActivityLocation(1136, 258, 20, &quot;study at library&quot;, ActivityType.Study),

            // STUDYING at CS building
            new ActivityLocation(1664, 24, 20, &quot;study&quot;, ActivityType.Study),

            // RECREATION at Duck pond
            new ActivityLocation(2031, 144, 20, &quot;feed the ducks&quot;, ActivityType.Recreation),

            // RECREATION at Sports Centre
            new ActivityLocation(970, 125, 20, &quot;play football&quot;, ActivityType.Recreation),

            // RECREATION in town
            new ActivityLocation(136, 280, 20, &quot;go clubbing&quot;, ActivityType.Recreation),

            // EATING at Piazza
            new ActivityLocation(2104, 264, 20, &quot;eat&quot;, ActivityType.Food),

            // EATING at Courtyard
            new ActivityLocation(1288, 55, 20, &quot;eat&quot;, ActivityType.Food),

            // EATING in town
            new ActivityLocation(633, 260, 20, &quot;eat&quot;, ActivityType.Food)


    };


    private InteractionPopup interaction_popup; // Add a field for the interaction pop-up
    private float popupX;
    private float popupY;
    private int interacted;
    private String reason;


    // CHANGELOG: Added attributes for the activity icon animations
    Animation&lt;TextureRegion&gt; sleepIcon;
    Animation&lt;TextureRegion&gt; eatIcon;
    Animation&lt;TextureRegion&gt; studyIcon;
    Animation&lt;TextureRegion&gt; feedDucksIcon;
    Animation&lt;TextureRegion&gt; playFootballIcon;
    Animation&lt;TextureRegion&gt; drinkIcon;
<span class="fc" id="L127">    Texture iconSpriteSheet = new Texture(Gdx.files.internal(ICON_ANIMATION_ASSET));</span>
    float stateTime;


    /**
     * CHANGELOG: UPDATED METHOD
     *
     * Constructs a new PlayScreen.
     * @param game The game instance.
     */
    public PlayScreen(HeslingtonHustle game)
<span class="fc" id="L138">    {</span>
<span class="fc" id="L139">        this.game = game;</span>


        // CHANGELOG: Initialise TextureRegions/Frames for the Activity Icons
<span class="fc" id="L143">        TextureRegion[][] tmp = TextureRegion.split(iconSpriteSheet, iconSpriteSheet.getWidth() / 6, iconSpriteSheet.getHeight()/6);</span>
<span class="fc" id="L144">        TextureRegion[] sleepFrames = new TextureRegion[6];</span>
<span class="fc" id="L145">        TextureRegion[] eatFrames = new TextureRegion[6];</span>
<span class="fc" id="L146">        TextureRegion[] studyFrames = new TextureRegion[6];</span>
<span class="fc" id="L147">        TextureRegion[] duckFrames = new TextureRegion[6];</span>
<span class="fc" id="L148">        TextureRegion[] footballFrames = new TextureRegion[6];</span>
<span class="fc" id="L149">        TextureRegion[] drinkFrames = new TextureRegion[6];</span>

<span class="fc bfc" id="L151" title="All 2 branches covered.">        for (int i = 0; i &lt; 6; i++) {</span>
<span class="fc" id="L152">            sleepFrames[i] = tmp[0][i];</span>
<span class="fc" id="L153">            eatFrames[i] = tmp[1][i];</span>
<span class="fc" id="L154">            studyFrames[i] = tmp[2][i];</span>
<span class="fc" id="L155">            duckFrames[i] = tmp[3][i];</span>
<span class="fc" id="L156">            footballFrames[i] = tmp[4][i];</span>
<span class="fc" id="L157">            drinkFrames[i] = tmp[5][i];</span>
        }
<span class="fc" id="L159">        float frameRate = 0.08f;</span>

<span class="fc" id="L161">        sleepIcon = new Animation&lt;TextureRegion&gt;(frameRate, sleepFrames);</span>
<span class="fc" id="L162">        eatIcon = new Animation&lt;TextureRegion&gt;(frameRate, eatFrames);</span>
<span class="fc" id="L163">        studyIcon = new Animation&lt;TextureRegion&gt;(frameRate, studyFrames);</span>
<span class="fc" id="L164">        feedDucksIcon = new Animation&lt;TextureRegion&gt;(frameRate, duckFrames);</span>
<span class="fc" id="L165">        playFootballIcon = new Animation&lt;TextureRegion&gt;(frameRate, footballFrames);</span>
<span class="fc" id="L166">        drinkIcon = new Animation&lt;TextureRegion&gt;(frameRate, drinkFrames);</span>

<span class="fc" id="L168">        stateTime = 0f;</span>
<span class="fc" id="L169">    }</span>

    /**
     * CHANGELOG: UPDATED METHOD
     *
     * Called when this screen becomes the current screen.
     * Initialises camera, viewport, tile map, and player avatar.
     */
    @Override
    public void show() {
        // Create camera and viewport
<span class="nc" id="L180">        this.camera = new OrthographicCamera();</span>

<span class="nc" id="L182">        this.core = new Core();</span>
        // Load tile Map
<span class="nc" id="L184">        this.tile_map = new TmxMapLoader().load(TILEMAP_ASSET); // load tile map</span>
<span class="nc" id="L185">        this.map_renderer = new OrthogonalTiledMapRenderer(this.tile_map);</span>

        // Set target aspect ratio for tile map
<span class="nc" id="L188">        float target_aspect_ratio = 16f / 9f;</span>

        // Calculate world dimensions
<span class="nc" id="L191">        final int map_tile_width = this.tile_map.getProperties().get(&quot;width&quot;, Integer.class);</span>
<span class="nc" id="L192">        final int map_tile_height = this.tile_map.getProperties().get(&quot;height&quot;, Integer.class);</span>
<span class="nc" id="L193">        final int tile_size = this.tile_map.getProperties().get(&quot;tilewidth&quot;, Integer.class);</span>
<span class="nc" id="L194">        this.world_width = map_tile_width * tile_size;</span>
<span class="nc" id="L195">        this.world_height = map_tile_height * tile_size;</span>


<span class="nc" id="L198">        this.player = new Avatar(0, 0, this.world_height, this.world_width);</span>
<span class="nc" id="L199">        this.player.setPlayerLoc(260+ (2*48*16), 250);</span>

        // Set the viewport to use the whole screen with the desired aspect ratio
<span class="nc" id="L202">        this.viewport = new FitViewport(this.world_width/3, this.world_height, this.camera);</span>
<span class="nc" id="L203">        this.hud = new HUD(this.core);</span>

        // Initialise the camera on the starting map section.
<span class="nc" id="L206">        this.camera.position.set((this.world_width / 2f)+map_section_offset, this.world_height / 2f, 0);</span>
<span class="nc" id="L207">        this.camera.update();</span>

        // Adjust the viewport if needed to ensure the tile map fills the entire screen (for tile maps that are not 16:9)
<span class="nc" id="L210">        float aspect_ratio = (float) Gdx.graphics.getHeight() / Gdx.graphics.getWidth();</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">        if (aspect_ratio &gt; target_aspect_ratio) {</span>
<span class="nc" id="L212">            final float new_world_height = this.world_width * aspect_ratio;</span>
<span class="nc" id="L213">            final float y_offset = (new_world_height - this.world_height) / 2f;</span>
<span class="nc" id="L214">            this.viewport.setWorldSize(this.world_width, new_world_height);</span>
<span class="nc" id="L215">            this.camera.position.add(0, y_offset, 0);</span>
<span class="nc" id="L216">            this.camera.update();</span>
        }



<span class="nc" id="L221">    }</span>

    /**
     * CHANGELOG: UPDATED METHOD
     *
     * Called when screen should render itself.
     * Handles input, updates the camera, renders the tile map, and renders the player sprite on top.
     *
     * @param delta time in seconds since the last render.
     */
    @Override
    public void render(float delta) {
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if(this.core.hasEnded()) {</span>
            // CHANGELOG : EndScreen now takes streakArray parameter
<span class="nc bnc" id="L235" title="All 2 branches missed.">            this.game.setScreen(new EndScreen(this.game, !this.core.hasPlayerFailed(), this.core.generateScore(activityLocations), this.core.checkStreaks(activityLocations)));</span>
        }
<span class="nc" id="L237">        handleInput(); // Call method to handle inputs</span>
<span class="nc" id="L238">        this.player.handleInput();</span>

        // CHANGELOG: Update which map section the player is currently in
<span class="nc" id="L241">        current_map_section = getGameArea(this.player.getPlayerX());</span>

        // CHANGELOG: Update the camera based on the current map section thep player is in
<span class="nc" id="L244">        this.camera.position.set(</span>
<span class="nc" id="L245">                (this.world_width / 2f) + (getGameArea(this.player.getPlayerX()) * map_section_offset),</span>
                this.world_height / 2f,
                0);

        // Update camera and viewport
<span class="nc" id="L250">        this.camera.update();</span>
<span class="nc" id="L251">        this.map_renderer.setView(this.camera);</span>
<span class="nc" id="L252">        this.hud.update(this.core, current_map_section);</span>
<span class="nc" id="L253">        this.player.update(this.tile_map);</span>
<span class="nc" id="L254">        this.core.update();</span>

        // Clear the screen
<span class="nc" id="L257">        Gdx.gl.glClearColor(0, 0, 0, 1);</span>
<span class="nc" id="L258">        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);</span>

<span class="nc" id="L260">        this.map_renderer.render(); // Render tile map</span>


        // Render player sprite
<span class="nc" id="L264">        this.map_renderer.getBatch().begin();</span>
<span class="nc" id="L265">        this.player.render(this.map_renderer);// Draw sprite in updated position with specified dimensions</span>

        // ADDING FLOATING ICONS FOR ACTIVITIES
<span class="nc" id="L268">        drawActivityIcons();</span>

<span class="nc" id="L270">        this.hud.render(this.map_renderer.getBatch());</span>

<span class="nc" id="L272">        this.map_renderer.getBatch().end();</span>


<span class="nc" id="L275">        checkInteractionProximity(); // Check for proximity and update interaction pop-ups</span>


        // Render the pop-up message if it exists
<span class="nc bnc" id="L279" title="All 2 branches missed.">        if (this.interaction_popup != null) {</span>
<span class="nc" id="L280">            this.interaction_popup.render(this.map_renderer.getBatch(), this.popupX, this.popupY); // Adjust popupX and popupY as needed</span>
        }
<span class="nc" id="L282">    }</span>

    /** Called when the window is resized.
     * Updates the viewport and ensures the sprite stays within the new window boundaries.
     * @param width  the new width in pixels.
     * @param height the new height in pixels.
     */
    @Override
    public void resize(int width, int height) {
        // Update viewport when the window is resized
<span class="nc" id="L292">        this.viewport.update(width, height);</span>
<span class="nc" id="L293">    }</span>

    /**
     * CHANGELOG: ADDED NEW METHOD.
     * Method used to draw floating activity icons to the map.
     */
    private void drawActivityIcons(){
        // Update the games state time
<span class="nc" id="L301">        stateTime += Gdx.graphics.getDeltaTime();</span>

<span class="nc bnc" id="L303" title="All 2 branches missed.">        for (ActivityLocation activity : activityLocations) {</span>
            // For each activity, check if it is in the current map section
<span class="nc bnc" id="L305" title="All 2 branches missed.">            if (getGameArea(activity.getX()) == current_map_section){</span>

                // If it is, animate its icon depending on the activity type/name

<span class="nc bnc" id="L309" title="All 5 branches missed.">                switch (activity.getType()){</span>
                    case Study:
<span class="nc" id="L311">                        iconAnimate(studyIcon, activity.getX(), activity.getY()+50);</span>
<span class="nc" id="L312">                        break;</span>

                    case Sleep:
<span class="nc" id="L315">                        iconAnimate(sleepIcon, activity.getX(), activity.getY()+30);</span>
<span class="nc" id="L316">                        break;</span>

                    case Recreation:
<span class="nc bnc" id="L319" title="All 4 branches missed.">                        switch (activity.getName()) {</span>
                            case &quot;feed the ducks&quot;:
<span class="nc" id="L321">                                iconAnimate(feedDucksIcon, activity.getX(), activity.getY());</span>
<span class="nc" id="L322">                                break;</span>
                            case &quot;play football&quot;:
<span class="nc" id="L324">                                iconAnimate(playFootballIcon, activity.getX(), activity.getY());</span>
<span class="nc" id="L325">                                break;</span>
                            case &quot;go clubbing&quot;:
<span class="nc" id="L327">                                iconAnimate(drinkIcon, activity.getX(), activity.getY()+50);}</span>
<span class="nc" id="L328">                        break;</span>

                    case Food:
<span class="nc" id="L331">                        iconAnimate(eatIcon, activity.getX(), activity.getY()+40);</span>
                        break;
                }
            }
        }
<span class="nc" id="L336">    }</span>


    /**
     * CHANGELOG: ADDED NEW METHOD.
     * Method used to animate activity icons.
     *
     * @param icon Icon to be animated.
     * @param x x-coordinate of icon animation.
     * @param y y-coordinate of icon animation.
     */
    private void iconAnimate(Animation&lt;TextureRegion&gt; icon, float x, float y){

        // Get the current frame of animation required
<span class="nc" id="L350">        TextureRegion currentFrame = icon.getKeyFrame(stateTime, true);</span>

        // Draw this frame at the activities position
<span class="nc" id="L353">        this.map_renderer.getBatch().draw(currentFrame, x ,y);</span>
<span class="nc" id="L354">    }</span>

    /**
     * CHANGELOG: ADDED NEW METHOD
     * This method takes an x coordinate and returns which location of the map it is in.
     *
     * @param xValue X Coordinate to check
     * @return -1 for left map (town), 0 for centre map (west), 1 for right map (east)
     */
    public int getGameArea(float xValue) {
<span class="fc bfc" id="L364" title="All 2 branches covered.">        if (xValue &gt; 1523) {</span>
<span class="fc" id="L365">            return 1; // East Campus (Right)</span>
<span class="pc bpc" id="L366" title="1 of 4 branches missed.">        } else if (xValue &lt;= 1523 &amp;&amp; xValue &gt; 755) {</span>
<span class="fc" id="L367">            return 0; // West Campus (Centre)</span>
        } else {
<span class="fc" id="L369">            return -1;// Town (Left)</span>
        }
    }


    /**
     * Handles user input to move the sprite with wasd keys.
     * Checks boundaries to prevent the sprite from moving outside the game window.
     */
    private void handleInput() {

        // Temporary: Used for Testing+Debugging
//        if(Gdx.input.isKeyPressed(Input.Keys.ALT_LEFT) &amp;&amp; Gdx.input.isKeyJustPressed(Input.Keys.S)) {
//            this.core.interactedWith(ActivityType.Study);
//        }
//        if(Gdx.input.isKeyPressed(Input.Keys.ALT_LEFT) &amp;&amp; Gdx.input.isKeyJustPressed(Input.Keys.F)) {
//            this.core.interactedWith(ActivityType.Food);
//        }
//        if(Gdx.input.isKeyPressed(Input.Keys.ALT_LEFT) &amp;&amp; Gdx.input.isKeyJustPressed(Input.Keys.E)) {
//            this.core.interactedWith(ActivityType.Sleep);
//        }
//        if(Gdx.input.isKeyPressed(Input.Keys.ALT_LEFT) &amp;&amp; Gdx.input.isKeyJustPressed(Input.Keys.R)) {
//            this.core.interactedWith(ActivityType.Recreation);
//        }
//        if(Gdx.input.isKeyPressed(Input.Keys.ALT_LEFT) &amp;&amp; Gdx.input.isKeyJustPressed(Input.Keys.W)) {
//            this.game.setScreen(new EndScreen(game, true, 2342));
//        }
//        if(Gdx.input.isKeyPressed(Input.Keys.ALT_LEFT) &amp;&amp; Gdx.input.isKeyJustPressed(Input.Keys.L)) {
//            this.game.setScreen(new EndScreen(game, false, 7613));
//        }
//
//        if (Gdx.input.isKeyJustPressed(Input.Keys.X)) {
//            System.out.println(this.player.getPlayerX());
//            System.out.println(this.player.getPlayerY());
//        }
//
//        if (Gdx.input.isKeyJustPressed(Input.Keys.Z)) {
//            System.out.println(&quot;----------&quot;);
//            for (ActivityLocation activity : activityLocations) {
//                System.out.println(Arrays.toString(activity.getInteractions()) + &quot;, &quot; + activity.getName());
//            }
//            System.out.println(&quot;----------&quot;);
//
//        }

        // Toggle fullscreen when F11 is pressed
<span class="nc bnc" id="L415" title="All 2 branches missed.">        if (Gdx.input.isKeyJustPressed(Input.Keys.F11)) {</span>
<span class="nc" id="L416">            toggleFullscreen();</span>
        }
        // Interact when &quot;E&quot; is pressed
<span class="nc bnc" id="L419" title="All 2 branches missed.">        if (Gdx.input.isKeyJustPressed(Input.Keys.E)) {</span>
<span class="nc" id="L420">            handleInteraction();</span>
        }


<span class="nc" id="L424">    }</span>

    /**
     * CHANGELOG: UPDATED METHOD
     *
     * Handles player interaction with various activity locations based on their proximity to the player's position.
     * Checks if the player is within the interaction area of each activity location
     * If the player is within range, trigger the interaction with the activity and handle any outcome.
     */
    private void handleInteraction() {
        // Get players current position
<span class="nc" id="L435">        final float playerX = this.player.getPlayerX();</span>
<span class="nc" id="L436">        final float playerY = this.player.getPlayerY();</span>
        ResourceExitConditions exit_value;


        // CHANGELOG: CHANGED THIS FUNCTION TO USE A LOOP TO ALLOW FOR EXTRA ACTIVITIES
        // CHANGELOG: ADDED LINE TO INCREMENT COUNTER FOR SPECIFIC ACTIVITY
<span class="nc bnc" id="L442" title="All 2 branches missed.">        for (ActivityLocation activity : activityLocations){</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">            if (isPlayerWithinInteractionArea(playerX, playerY, activity)){</span>
                // Updated the frames since the last interaction to be 0
<span class="nc" id="L445">                frames_since_int = 0;</span>
<span class="nc bnc" id="L446" title="All 4 branches missed.">                if (activity.getType() == ActivityType.Study || activity.getType() == ActivityType.Recreation){</span>
<span class="nc" id="L447">                    exit_value = this.core.interactedWith(activity.getType());</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">                    if (exit_value.getConditions() == ExitConditions.IsOk){</span>
                        // Increments counter within activity object
<span class="nc" id="L450">                        activity.incrementCounter(this.core.getCurrentDay() - 1);</span>
<span class="nc" id="L451">                        interacted = 1;</span>
<span class="nc" id="L452">                        return;</span>
                    }
<span class="nc" id="L454">                    interacted = -1;</span>
<span class="nc" id="L455">                    reason = String.format(&quot;%s %s\n&quot;, exit_value.getTypes().toString(), exit_value.getConditions().toString().substring(4));</span>
                }

<span class="nc bnc" id="L458" title="All 2 branches missed.">                if (activity.getType() == ActivityType.Food) {</span>
<span class="nc" id="L459">                    exit_value = this.core.interactedWith(ActivityType.Food);</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">                    if (exit_value.getConditions() == ExitConditions.IsOk){</span>
                        // Increments counter within activity object
<span class="nc" id="L462">                        activity.incrementCounter(this.core.getCurrentDay() - 1);</span>
<span class="nc" id="L463">                        interacted = 1;</span>
                    }
                    else{
<span class="nc" id="L466">                        interacted = -1;</span>
<span class="nc" id="L467">                        reason = String.format(&quot;%s %s\n&quot;, exit_value.getTypes().toString(), exit_value.getConditions().toString().substring(4));</span>
                    }
<span class="nc" id="L469">                    return;</span>
                }

<span class="nc bnc" id="L472" title="All 4 branches missed.">                if (activity.getType() == ActivityType.Sleep &amp;&amp; interacted == 0) {</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">                    if(this.core.isLastDay()) {</span>
                        // CHANGELOG : EndScreen now takes streakArray parameter
<span class="nc bnc" id="L475" title="All 2 branches missed.">                        game.setScreen(new EndScreen(this.game, !this.core.hasPlayerFailed(), this.core.generateScore(activityLocations), this.core.checkStreaks(activityLocations)));</span>
                    }
<span class="nc" id="L477">                    else this.core.interactedWith(ActivityType.Sleep);</span>
<span class="nc" id="L478">                    interacted = 1;</span>
                }



            }
        }


<span class="nc" id="L487">    }</span>

    /**
     * CHANGELOG: UPDATED METHOD
     * Checks the proximity of the player to various activity locations and updates the interaction pop-up message accordingly.
     * If the player is within range of an activity location, an interaction pop-up message is displayed.
     * If the player is not within range of any activity location, the interaction pop-up is hidden.
     */
    private void checkInteractionProximity() {
        // Get players current position
<span class="nc" id="L497">        final float playerX = this.player.getPlayerX();</span>
<span class="nc" id="L498">        final float playerY = this.player.getPlayerY();</span>

<span class="nc" id="L500">        boolean near_activity = false;</span>

        // set pop up above players location
<span class="nc" id="L503">        this.popupX = playerX;</span>
<span class="nc" id="L504">        this.popupY = playerY + 50;</span>

        // CHANGELOG: Increment frames since last interaction
<span class="nc" id="L507">        frames_since_int += 1;</span>

        // CHANGELOG: CHANGED THIS FUNCTION TO USE A LOOP TO ALLOW FOR EXTRA ACTIVITIES
        // CHANGELOG: ADDED COLOURS TO INTERACTION POPUPS BASED ON INTERACTION STATUS
<span class="nc bnc" id="L511" title="All 2 branches missed.">        for (ActivityLocation activity : activityLocations){</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">            if (isPlayerWithinInteractionArea(playerX, playerY, activity)){</span>
<span class="nc" id="L513">                String colour = &quot;white&quot;;</span>
<span class="nc" id="L514">                String message = &quot;Press E to &quot;+ activity.getName();</span>
<span class="nc bnc" id="L515" title="All 4 branches missed.">                if(interacted == 1 &amp;&amp; frames_since_int &lt; 60){</span>
<span class="nc" id="L516">                    colour = &quot;green&quot;;</span>
                }
<span class="nc bnc" id="L518" title="All 4 branches missed.">                else if (interacted == -1 &amp;&amp; frames_since_int &lt; 60){</span>
<span class="nc" id="L519">                    colour = &quot;red&quot;;</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">                    if (reason.equals(&quot;Time too low\n&quot;)){</span>
<span class="nc" id="L521">                        message = &quot;Not enough time&quot;;</span>
                    }
                    else {
<span class="nc" id="L524">                        message = reason;</span>
                    }
                }
                else{
<span class="nc" id="L528">                    interacted = 0;</span>
                }

<span class="nc" id="L531">                this.interaction_popup = new InteractionPopup(message, colour);</span>
<span class="nc" id="L532">                near_activity = true;</span>
            }
        }

<span class="nc bnc" id="L536" title="All 2 branches missed.">        if (!near_activity){</span>
<span class="nc" id="L537">            this.interaction_popup = null;</span>
<span class="nc" id="L538">            interacted = 0;</span>
        }


<span class="nc" id="L542">    }</span>

    /**
     * Toggles fullscreen mode of the application.
     * If the application is currently in fullscreen mode, it switches to windowed mode with the dimensions of the game world.
     * If the application is in windowed mode, it switches to fullscreen mode using the current display mode.
     */
    private void toggleFullscreen() {
<span class="nc bnc" id="L550" title="All 2 branches missed.">        this.is_fullscreen = !this.is_fullscreen;</span>

<span class="nc bnc" id="L552" title="All 2 branches missed.">        if (this.is_fullscreen) {</span>
<span class="nc" id="L553">            Gdx.graphics.setFullscreenMode(Gdx.graphics.getDisplayMode());</span>
        } else {
<span class="nc" id="L555">            Gdx.graphics.setWindowedMode((int) this.world_width/3, (int) this.world_height);</span>
        }
<span class="nc" id="L557">    }</span>

    /**
     * Checks if the player is within the interaction area of a given activity location.
     *
     * @param playerX   The x-coordinate of the player's position.
     * @param playerY   The y-coordinate of the player's position.
     * @param location  The activity location to check for interaction area.
     * @return True if the player is within the interaction area of the activity location, false otherwise.
     */
    public boolean isPlayerWithinInteractionArea(float playerX, float playerY, ActivityLocation location) {
        // Calculate the squared distance between the player and the activity location
<span class="fc" id="L569">        float distance_squared = (playerX - location.getX()) * (playerX - location.getX())</span>
<span class="fc" id="L570">                + (playerY - location.getY()) * (playerY - location.getY());</span>
        // Compare squared distance with the square of the interaction radius of the location
<span class="fc bfc" id="L572" title="All 2 branches covered.">        return distance_squared &lt;= location.getRadius() * location.getRadius();</span>
    }

    @Override
    public void pause() {
<span class="nc" id="L577">    }</span>

    @Override
    public void resume() {
<span class="nc" id="L581">    }</span>

    @Override
    public void hide() {
<span class="nc" id="L585">    }</span>

    /** Called when the application is destroyed. Preceded by a call to {@link #pause()}. */
    @Override
    public void dispose() {
<span class="nc" id="L590">        this.tile_map.dispose();</span>
<span class="nc" id="L591">        this.map_renderer.dispose();</span>
<span class="nc" id="L592">        this.player.dispose();</span>
<span class="nc" id="L593">        this.hud.dispose();</span>
<span class="nc" id="L594">        this.interaction_popup.dispose();</span>

        // CHANGELOG: Need to Dispose of activity icon sprites.
<span class="nc" id="L597">        this.iconSpriteSheet.dispose();</span>
<span class="nc" id="L598">    }</span>

    /**
     * CHANGELOG: ADDED METHODS
     * Added getter methods for testing
     * @return World Height/Width
     */
<span class="nc" id="L605">    public float getWorldHeight(){return this.world_height;}</span>
<span class="nc" id="L606">    public float getWorldWidth(){return this.world_width;}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>